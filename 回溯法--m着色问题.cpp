/*---------------------------------------------------------------------------

问题：
采用递归回溯法设计一个算法，
求从1~n的n个整数中取出m个元素的排列
，要求每个数据元素只能取一次。
例如：n=3、m=2的输出结果是（1,2）（1,3）（2,1）（2,3）（3,1）（3,2）

----------------------------------------------------------------------------*/
#include <iostream>
#include<stdio.h>
#include<stdlib.h>
using namespace std;
int n;//n个节点
int m;//m种颜色
int mm[100][100];//记录图的邻接矩阵
int x[100];//记录树的一条枝，即图着色的一种可能性，x[i]=1,2,3..k..n代表第节点i颜色为k
int bestx[100];
int sum=0;//用来记录当前可行的着色方案
//分析本题的约束函数为两节点相连且同种颜色时，不会继续往下发展这种可能性
bool ok(int i)
{
    int j;
    for(j=1;j<=n;j++)
    {
        if((mm[i][j]==1)&&(x[i]==x[j]))//我到底和哪些节点相连且颜色一样
        {
            return false;
        }
    }
    return true;
}
void dfs(int i)
{
    int j;
    if(i>n)
    {
        sum++;
        for(j=1;j<=n;j++)
        {
            bestx[j]=x[j];//记录一条枝(记录一种着色的可能性)
        }
    }
    else
    {
        for(j=1;j<=m;j++)//在i节点处检测它自己可能填的m种可能性
        {
             x[i]=j;//i节点选定了一种颜色
            if(ok(i))//通过约束函数去掉不合理的颜色可能性
            {
                 dfs(i+1);//活节点转移到下一层的第i+1个节点
            }

             x[i]=0;//无实义，为i继续换别的颜色可能性
        }
    }
}
int main()
{
    int t,k;
    int i,j;
    cout<<"分别输入n，k，m"<<endl;
    cin>>n>>k>>m;
    for(t=0;t<k;t++)
    {
        cout<<"输入边：";
        scanf("%d %d",&i,&j);
        mm[i][j]=1;
        mm[j][i]=1;
    }
    dfs(1);

    cout<<"着色总数："<<sum<<endl;
    return 0;
}
